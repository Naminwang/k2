(cd build;make); build/bin/cu_integral_test >& build/foo ; grep "For r" build/foo; grep "For r" build/foo  |  awk '{for (n=12;n<=15;n++) { if ($n == "=") { m=n+1; sum += $m; sumsq += $m*$m;}}} END{sumsq/=NR;sum/=NR; stddev=sqrt(sumsq - sum*sum); rel_stddev=stddev/sum; print "Rel stddev is ", rel_stddev;}'; grep "alpha =" k2/csrc/integral.h

  return 1000.0 * pow(tmm, 1.0/3);  -> Rel stddev is  0.00124782
  return  pow(tmm, 1.0/3);  -> Rel stddev is  0.00124817
  return pow(abs(eigs.x[0]) + abs(eigs.x[1]) + abs(eigs.x[2]), 2.0 / 3);  -> Rel stddev is  0.0016257

  double alpha = 1.0, beta = 0.0, gamma = 0.0, delta = 0.0, ->  Rel stddev is  0.0029565
  double alpha = -1.0, beta = 0.0, gamma = 0.0, delta = 0.0 ->  Rel stddev is  0.00285662
 double alpha = -0.5, beta = 0.0, gamma = 0.0, delta = 0.0, ->  Rel stddev is  0.000396197
  double alpha = -0.66, beta = 0.0, gamma = 0.0, delta = 0.0 -> Rel stddev is  0.000994683
  double alpha = -0.4, beta = 0.0, gamma = 0.0, delta = 0.0, ->Rel stddev is  0.000269894
  double alpha = -0.33, beta = 0.0, gamma = 0.0, delta = 0.0, ->Rel stddev is  0.00039694
  double alpha = -0.45, beta = 0.0, gamma = 0.0, delta = 0.0, ->Rel stddev is  0.000284813
  double alpha = -0.40, beta = 0.0, gamma = 0.0, delta = 0.2 -> Rel stddev is  0.000348723
  double alpha = -0.40, beta = 0.0, gamma = 0.0, delta = -0.2 ->  Rel stddev is  0.000298288
  double alpha = -0.40, beta = 0.0, gamma = 0.0, delta = -0.1 -> Rel stddev is  0.000266256
  double alpha = -0.35, beta = 0.0, gamma = 0.0, delta = -0.1, -> Rel stddev is  0.000302492
   double alpha = -0.45, beta = 0.0, gamma = 0.0, delta = -0.1,->Rel stddev is  0.000341473

  return pow(pos_eigs, 2.0/3); -> Rel stddev is  0.00162583
  return pow(-neg_eigs, 2.0/3); -> Rel stddev is  0.00162583  # note, they are equal bc sum to zero, duh...
  return pow(pos_eigs_sq, 1.0/3);    Rel stddev is  0.00175108
  return pow(neg_eigs_sq, 1.0/3);  ->   Rel stddev is  0.000454318
  return pow(neg_eigs_sq + -0.5 * pos_eigs_sq, 1.0/3); -> Rel stddev is  0.51
  return pow(neg_eigs_sq + -0.1 * pos_eigs_sq, 1.0/3); -> Rel stddev is  0.000281398
  return pow(neg_eigs_sq + -0.05 * pos_eigs_sq, 1.0/3); ->Rel stddev is  0.00035911
  return pow(-eigs.x[2], 1.0/3); -> Rel stddev is  0.00104738

# pos_eigs_pos is sum of eigs^2/3
  return pos_eigs_pow + -0.24 * neg_eigs_pow; Rel stddev is  0.0010378
    return pos_eigs_pow -> Rel stddev is  0.00140792

 return pos_eigs_pow + -0.5 * neg_eigs_pow; ->  Rel stddev is  0.000192793
 return pos_eigs_pow + -0.55 * neg_eigs_pow; ->Rel stddev is  0.000576077
  return pos_eigs_pow + -0.45 * neg_eigs_pow; ->   Rel stddev is  0.000321848
return pos_eigs_pow + -0.475 * neg_eigs_pow; -> Rel stddev is  0.000211035
  return pos_eigs_pow + -0.49 * neg_eigs_pow; -> Rel stddev is  0.000179328 <------ Best with eigs.
return pos_eigs_pow + -0.485 * neg_eigs_pow; -> Rel stddev is  0.000184084
  return pos_eigs_pow + -0.495 * neg_eigs_pow; -> Rel stddev is  0.000182098

HERE (above)... is the best one...

 =========================
  # note, the 10 is just to tune the number of integral cubes, constant factor
  # doesn't matter.
  return 10.0*f_of_a * factor1;  ->  Rel stddev is  0.00116604
   # As above but computing integral with 1/3 power of arg then squaring afterward:
         Rel stddev is  0.000296888
 as above but with neg_sign_scale = -0.5  -> Rel stddev is  0.00512772
  as above but with neg_sign_scale = -0.1  -> Rel stddev is 0.000322598
  as above but neg_sign_scale = -0.075, -> Rel stddev is  0.000261929
..  neg_sign_scale = -0.05, -> Rel stddev is  0.000239157
  Wait, just realized the above was with 1/3 power in integral then squaring
  afterward, stopping that and using 2/3 power
    neg_sign_scale = 0.0 -> Rel stddev is  0.00116626
    neg_sign_scale = -0.2 -> Rel stddev is  0.000979471
   neg_sign_scale = -0.4 ->   Rel stddev is  0.000643887
 neg_sign_scale = -0.5 ->   Rel stddev is  0.000369087
 neg_sign_scale = -0.66 -> Rel stddev is  0.00084924
  neg_sign_scale = -0.55 ->  Rel stddev is  0.000241166
  neg_sign_scale = -0.575 -> Rel stddev is  0.000250186
  # as above but with 200 not 100 steps in integral
  neg_sign_scale=-0.525->  Rel stddev is  0.000325061
  neg_sign_scale=-0.5->  Rel stddev is  0.000404438
  neg_sign_scale =-0.55->Rel stddev is  0.000254502
  neg_sign_scale =-0.575->Rel stddev is  0.000228082 <------ best with integral.
  neg_sign_scale =-0.60->Rel stddev is  0.000291742

=============
  return  (1.0+cos_angle) * pow(pow2, 1.0/3); -> Rel stddev is  0.00420895
  return  (1.0+0.5*cos_angle) * pow(pow2, 1.0/3); -> Rel stddev is  0.00321478
  return  (1.0+0.2*cos_angle)  * pow(pow2, 1.0/3); ->  Rel stddev is  0.00222609
  return  (1.0-0.2*cos_angle) * pow(pow2, 1.0/3); -> Rel stddev is  0.000368394
  return  (1.0-0.15*cos_angle) * pow(pow2, 1.0/3); ->Rel stddev is  0.000315268
  return  (1.0-0.15*cos_angle+0.1*sin_angle) * pow(pow2, 1.0/3); ->Rel stddev is  0.00212843
 ->return  (1.0-0.15*cos_angle-0.1*sin_angle) * pow(pow2, 1.0/3)-> Rel stddev is  0.00242893
return  (1.0-0.15*cos_angle-0.02*sin_angle) * pow(pow2, 1.0/3);-> Rel stddev is  0.000657689
  return  (1.0-0.15*cos_angle+0.02*sin_angle) * pow(pow2, 1.0/3); -> Rel stddev is 0.000418868
   return  (1.0-0.125*cos_angle) * pow(pow2, 1.0/3); ->Rel stddev is  0.000456749
   return  (1.0-0.175*cos_angle) * pow(pow2, 1.0/3);->Rel stddev is  0.000264359
  return  (1.0-0.225*cos_angle) * pow(pow2, 1.0/3); ->Rel stddev is  0.00056175
  return  (1.0-0.19*cos_angle) * pow(pow2, 1.0/3); ->Rel stddev is  0.000311165
  return  (1.0-0.19*cos_angle+0.05*cos2_angle) * pow(pow2, 1.0/3);->Rel stddev is  0.000420418
  return  (1.0-0.175*cos_angle-0.05*cos2_angle) * pow(pow2, 1.0/3);->Rel stddev is  0.00065988
  return  (1.0-0.175*cos_angle-0.02*cos2_angle) * pow(pow2, 1.0/3);->Rel stddev is  0.000369426
  return  (1.0-0.175*cos_angle+0.02*cos2_angle) * pow(pow2, 1.0/3);->Rel stddev is  0.000305123
    return  (1.0-0.175*cos_angle+0.02*sin2_angle) * pow(pow2, 1.0/3);->Rel stddev is  0.000346104
return  (1.0-0.175*cos_angle-0.02*cos3_angle) * pow(pow2, 1.0/3);->Rel stddev is  0.000414005
  return  (1.0-0.15*cos_angle+0.05*angle) * pow(pow2, 1.0/3);->Rel stddev is  0.00116659
    return  (1.0-0.15*cos_angle+0.1*angle) * pow(pow2, 1.0/3);->Rel stddev is  0.00242576
  return  (1.0-0.15*cos_angle+0.02*angle) * pow(pow2, 1.0/3);->Rel stddev is  0.000457798

  return  (1.0-0.20*cos_angle-0.02*angle) * pow(pow2, 1.0/3);->Rel stddev is  0.000370314

  return  (1.0-0.20*cos_angle-0.03*angle) * pow(pow2, 1.0/3);->Rel stddev is  0.000601735
  return  (1.0-0.18*cos_angle) * pow(pow2, 1.0/3);->Rel stddev is  0.000273638
  return  (1.0-0.18*cos_angle+0.01*sin_angle) * pow(pow2, 1.0/3);->Rel stddev is  0.000421143
   return  (1.0-0.18*cos_angle-0.01*sin_angle) * pow(pow2, 1.0/3);->Rel stddev is Rel stddev is  0.000286383
     return  (1.0-0.18*cos_angle-0.005*sin_angle) * pow(pow2, 1.0/3);->Rel stddev is  0.000254399
 return  (1.0-0.18*cos_angle-0.005*sin_angle-0.005*sin2_angle) * pow(pow2, 1.0/3);->Rel stddev is  0.000262281
return  (1.0-0.18*cos_angle-0.005*sin_angle+0.005*sin2_angle) * pow(pow2, 1.0/3);-> Rel stddev is  0.000254494

  return pow(abs(eigs.x[0]) + abs(eigs.x[1]) + abs(eigs.x[2]) + 0.5*sqrt(tmm), 2.0 / 3); -> Rel variance is  0.0138227
  return pow(abs(eigs.x[0]), 2.0/3) + pow(abs(eigs.x[1]), 2.0/3) + pow(abs(eigs.x[2]), 2.0/3) ->  Rel variance is  0.0116099
  return pow(abs(eigs.x[0]-eigs.x[1]) + abs(eigs.x[1]-eigs.x[2]) + abs(eigs.x[2]-eigs.x[0]), 2.0/3); -> Rel variance is  0.0125291
 return pow(abs(eigs.x[0]*eigs.x[1]) + abs(eigs.x[1]*eigs.x[2]) + abs(eigs.x[2]*eigs.x[0]), 1.0/3); -> Rel variance is  0.0243561
  return pow(abs(eigs.x[0]-eigs.x[2]), 2.0/3);->Rel variance is  0.0201416


 return pow(abs(eigs.x[0]), 2.0/3) + pow(abs(eigs.x[1]), 2.0/3) + pow(abs(eigs.x[2]), 2.0/3) + pow(tmm, 1.0/3); -> Rel variance is  0.00770305
 return pow(abs(eigs.x[0]), 2.0/3) + pow(abs(eigs.x[1]), 2.0/3) + pow(abs(eigs.x[2]), 2.0/3) + 2.0*pow(tmm, 1.0/3); -> Rel variance is  0.00576356
 return 0.2 * (pow(abs(eigs.x[0]), 2.0/3) + pow(abs(eigs.x[1]), 2.0/3) + pow(abs(eigs.x[2]), 2.0/3) + 2.0*pow(tmm, 1.0/3)); -> Rel variance is  0.0288177

  return 10.0 * pow(tmm, 1.0/3);  -> Rel variance is  0.00228911

  return 1000.0 * pow(tmm, 1.0/3);  -> Rel variance is  2.28944e-05
